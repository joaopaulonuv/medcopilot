import AsyncStorage from '@react-native-async-storage/async-storage';
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';
import { MedicalAnalysis } from './AnalysisService';
import { TranscriptionChunk } from './AudioService';

export class StorageService {
  private static readonly ANALYSIS_KEY = 'medical_analysis';
  private static readonly CONFIG_KEY = 'app_config';
  private static readonly CHUNKS_KEY = 'transcription_chunks';

  static async saveAnalysis(analysis: MedicalAnalysis): Promise<void> {
    try {
      const analysisData = JSON.stringify(analysis);
      await AsyncStorage.setItem(this.ANALYSIS_KEY, analysisData);
    } catch (error) {
      console.error('Failed to save analysis:', error);
      throw new Error('Failed to save analysis data');
    }
  }

  static async getLatestAnalysis(): Promise<MedicalAnalysis | null> {
    try {
      const analysisData = await AsyncStorage.getItem(this.ANALYSIS_KEY);
      
      if (!analysisData) {
        return null;
      }

      return JSON.parse(analysisData) as MedicalAnalysis;
    } catch (error) {
      console.error('Failed to load analysis:', error);
      return null;
    }
  }

  static async saveTranscriptionChunk(chunk: TranscriptionChunk): Promise<void> {
    try {
      const existingChunks = await this.getTranscriptionChunks();
      const updatedChunks = [...existingChunks, chunk];
      
      await AsyncStorage.setItem(this.CHUNKS_KEY, JSON.stringify(updatedChunks));
    } catch (error) {
      console.error('Failed to save transcription chunk:', error);
    }
  }

  static async getTranscriptionChunks(): Promise<TranscriptionChunk[]> {
    try {
      const chunksData = await AsyncStorage.getItem(this.CHUNKS_KEY);
      
      if (!chunksData) {
        return [];
      }

      return JSON.parse(chunksData) as TranscriptionChunk[];
    } catch (error) {
      console.error('Failed to load transcription chunks:', error);
      return [];
    }
  }

  static async clearTranscriptionChunks(): Promise<void> {
    try {
      await AsyncStorage.removeItem(this.CHUNKS_KEY);
    } catch (error) {
      console.error('Failed to clear transcription chunks:', error);
    }
  }

  static async exportAnalysis(analysis: MedicalAnalysis): Promise<void> {
    try {
      const reportContent = this.generateReportContent(analysis);
      const fileName = `medical-analysis-${new Date().toISOString().split('T')[0]}.txt`;
      const fileUri = `${FileSystem.documentDirectory}${fileName}`;

      await FileSystem.writeAsStringAsync(fileUri, reportContent);
      
      if (await Sharing.isAvailableAsync()) {
        await Sharing.shareAsync(fileUri, {
          mimeType: 'text/plain',
          dialogTitle: 'Export Medical Analysis',
        });
      }
    } catch (error) {
      console.error('Failed to export analysis:', error);
      throw new Error('Failed to export analysis');
    }
  }

  private static generateReportContent(analysis: MedicalAnalysis): string {
    return `
MEDICAL CONSULTATION ANALYSIS REPORT
Generated: ${new Date(analysis.timestamp).toLocaleString()}

EXECUTIVE SUMMARY
${analysis.summary}

REPORTED SYMPTOMS
${analysis.symptoms.map(symptom => `• ${symptom}`).join('\n')}

DIFFERENTIAL DIAGNOSIS
${analysis.differentialDiagnosis.map(diagnosis => `• ${diagnosis}`).join('\n')}

CRITICAL ALERTS
${analysis.redFlags.length > 0 ? analysis.redFlags.map(flag => `⚠️ ${flag}`).join('\n') : 'None identified'}

MEDICATIONS MENTIONED
${analysis.medications.length > 0 ? analysis.medications.map(med => `• ${med}`).join('\n') : 'None mentioned'}

CLINICAL RECOMMENDATIONS
${analysis.recommendations.map(rec => `• ${rec}`).join('\n')}

TRANSCRIPTION TIMELINE
${analysis.chunks.length > 0 ? 
  analysis.chunks.map((chunk, index) => 
    `[${new Date(chunk.timestamp).toLocaleTimeString()}] ${chunk.text}`
  ).join('\n') : 'No timeline data available'}

FULL TRANSCRIPTION
${analysis.transcription}

---
This report was generated by AI and should be reviewed by a qualified healthcare professional.
Report ID: ${analysis.timestamp}
    `.trim();
  }

  static async clearAllData(): Promise<void> {
    try {
      await AsyncStorage.multiRemove([this.ANALYSIS_KEY, this.CONFIG_KEY, this.CHUNKS_KEY]);
    } catch (error) {
      console.error('Failed to clear data:', error);
      throw new Error('Failed to clear application data');
    }
  }
}